
// update single key in writable store of object type
export function updateObjectStore(store, key, val) {
  store.update(state => Object.assign({}, state, { [key]: val}));
}

// flattens our tree data structure into single array
export function flattenTree(branch, res = [], cdepth = 1, rdepth = {}) {
  let children;
  if (branch.children && branch.children.length > 0) {
    children = [...branch.children];
    branch.childrenCount = children.length;
  }
  delete branch.children;
  branch.cdepth = cdepth;
  rdepth[cdepth] = rdepth[cdepth] ? [...rdepth[cdepth], ''] : [''];
  branch.rdepth = rdepth[cdepth].length;
  res.push(branch);
  children && children.forEach((child) => {
    const parent = getFullBranchName(branch);
    return flattenTree({...child, parent }, res, cdepth + 1, rdepth)
  });
  return res;
}

// gets unique-ish name for each branch
export function getFullBranchName(branch) {
  return branch.parent ? `${branch.parent}|${branch.name}` : branch.name;
}

// add new leaf to specific parent
export function addDeepChildren(store, {name, parent}) {
  let tree;
  const parentChain = parent.split('|');
  const unsubscribe = store.subscribe(value => { tree = Object.assign({}, value); });

  if (parentChain.length === 1) {
    tree.children.push({name, parent});
  } else {
    let evalString = 'tree.children';
    for (let i = 1; i < parentChain.length; i++) {
      evalString += `.find( (leaf) => leaf.name === '${parentChain[i]}')`;
      evalString += (i < parentChain.length - 1) ? '.children' : '';
    }
    const deepLeaf = eval(evalString);
  
    if (deepLeaf.children) {
      deepLeaf.children.push({name, parent});
    } else {
      deepLeaf.children = [{name, parent}];
    }
  }
  store.update( (value) => Object.assign({}, value, tree) );
  unsubscribe();
}

// get path for line between 2 elements
export function getPath(start, end) {
  if (!start || !end) { return; }

  return `M ${start.x} ${start.y} q 0 ${end.y - start.y} ${end.x - start.x} ${end.y - start.y}`;
}
